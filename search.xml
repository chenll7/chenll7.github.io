<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>以太坊Sharding笔记</title>
      <link href="2020/11/04/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Ethereum_Sharding_Notes/"/>
      <url>2020/11/04/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Ethereum_Sharding_Notes/</url>
      
        <content type="html"><![CDATA[<h1>以太坊Sharding笔记</h1><h2 id="Sharding（分片）">Sharding（分片）</h2><p>参考：<br><a href="https://medium.com/@icebearhww/ethereum-sharding-and-finality-65248951f649">https://medium.com/@icebearhww/ethereum-sharding-and-finality-65248951f649</a>（推荐从这个看起，这个最简单）<br><a href="https://github.com/ethereum/wiki/wiki/Sharding-FAQ">https://github.com/ethereum/wiki/wiki/Sharding-FAQ</a>（Vitalik的关于sharding的问答）<br><a href="http://ethfans.org/posts/Sharding-FAQ">http://ethfans.org/posts/Sharding-FAQ</a>（上文的翻译）<br><a href="https://www.coindesk.com/information/will-ethereum-scale/">https://www.coindesk.com/information/will-ethereum-scale/</a><br><a href="https://medium.com/@rauljordan/how-to-scale-ethereum-sharding-explained-ba2e283b7fce">https://medium.com/@rauljordan/how-to-scale-ethereum-sharding-explained-ba2e283b7fce</a></p><p>validator：验证者<br>collator：整理者、校对者</p><h3 id="简介">简介</h3><p>目前，在所有的区块链协议中每个节点存储所有的状态（账户余额，合约代码和存储等等）并且<strong>处理所有的交易</strong>。这提供了大量的安全性，但极大的限制了可扩展性：<strong>区块链不能处理比一个单节点更多的交易</strong>。很大程度上因为这个原因，比特币被限制在每秒3-7笔交易，以太坊每秒7-15笔交易，等等。然后，这提出了一个问题：是否有方法创建一个新的机制，只让一个小集合的节点来验证每笔交易？只要有足够多的节点验证每笔交易那么系统依然是高度安全的，但又足够少使得系统系统可以并行处理很多的交易，我们是否可以使用这种技术来大大增加区块链的吞吐量？</p><p>以太坊Sharding就是采用这种思想设计的。和比特币闪电网络的目的相同，他们都是为了提高系统的吞吐量的等指标。</p><h2 id="Sharding的整体结构">Sharding的整体结构</h2><img src="/2020/11/04/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Ethereum_Sharding_Notes/20190302101730.png" class=""><p>我们看到Sharding跟比特币闪电网络的精神有相通之处，即避免大量交易进入主链，避免每笔交易都要所有验证者进行验证。</p><p>在每个分片内，每一个时间段内collators会产生的被称为collation的数据结构，collation会把打包这个时间段产生的交易。它的过程和主链上的矿工打包区块的过程相似。</p><h3 id="collator和collation">collator和collation</h3><p>在一个分片内有多个名为collator的节点，collator是从validators中随机抽取的。每个collator都有创建一个collation的任务。一个collation是长这样的：</p><img src="/2020/11/04/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Ethereum_Sharding_Notes/20190302101747.png" class=""><p>collation包含有该分片的重要信息。collation就像对这个分片的状态和交易的“迷你描述”。collation header内容包括：</p><ul><li>对应哪个分片</li><li>分片中所有交易被apply之前的分片的<strong>状态</strong>（具体应该是状态根哈希）</li><li>所有交易被apply之后的分片的<strong>状态</strong>（具体应该是状态根哈希）</li><li>至少2/3的collators的签名，证明collation是合法的</li></ul><p>所谓<strong>状态</strong>在以太坊中指所有账户和对应的余额、智能合约代码、给定时间的nounces的集合。</p><p><strong>超级节点</strong>把自己知道的所有分片的的<strong>证明</strong>记录在主链上，就像侧链锚定一样。</p><p>如果满足以下条件，那么这个区块是合法的：</p><ul><li>所有collations里的的交易都是合法的</li><li>交易前collations的状态和collations现在的状态相同</li><li>交易后collations的状态和collation headers指定的状态相同</li><li>2/3签名</li></ul><p>总而言之，collators是维持一个分片存在的角色。</p><h3 id="异步跨分片交易">异步跨分片交易</h3><p>用户可以在某个分片上发一笔交易：锁定一些ether，并在主链上生成一个receipt。另一个shard的用户可以发一笔receipt-consuming transaction，附上receipt ID来花费这笔交易。</p><p>A(Shard1上的地址) 想给B（Shard10地址）发送100ETH ：<br>（1）Shard1把A余额减100，系统等待交易完结。<br>（2）交易的收据（receipt）被创建。收据不保存在<strong>状态</strong>，而在默克尔树根，从而容易被验证。（？？？）<br>（3）交易和收据一起被发送到Shard10。Shard10检查收据是否仍未被花费。<br>（4）Shard10把B余额加100。并记录从Shard1送过来的收据被花费。<br>（5）Shard10创建可以被随后交易使用的收据。（？？？）</p><h3 id="安全风险">安全风险</h3><p>攻击者可能控制单个分片的大部分collators从而控制某个分片，即所谓<strong>单分片接管攻击</strong>。超级节点会获得不合法的collation。</p><p><img src="/2020/11/04/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Ethereum_Sharding_Notes/20190302101712.png" class=""></p><p>解决的方法是，在每个分片的collators是随机抽取出的。validators不会提前知道会成为哪个分片的collator。每个分片会被分配一组collators。</p><p>以太坊改用PoS共识算法之后，全球有一组validators，collators会从中被随机抽取出。随机源必须要是一致的保证抽样是entirely compulsory，并且can’t be gamed by the validators in question。</p><h3 id="验证者管理合约（Validator-Manager-Contract-VMC）">验证者管理合约（Validator Manager Contract,VMC）</h3><p>为了加入分片，肯定会使用这个智能合约，它有以下特征：</p><ol><li>PoS系统。如果某个验证者（validator）行为不端，它的stack会被罚没。</li><li>伪随机抽样（sampling）。上一个区块的哈希作为随机种子来抽取合适的collators。validators把自己的stack锁定在VMC，那么它们的validation code address将会被记录在全球验证者池列表中。多天前是无法预测某个validator会在在哪个<strong>period</strong>成为哪个分片的collator。</li><li>Collation header验证。VMC提供函数进行Collation header验证和记录。</li><li>跨分片交易。</li><li>On-chain governance. With VMC as the parliament, it enables validators to vote on-chain.</li></ol><p>对于所谓的period，目前VMC中<code>PERIOD_LENGTH = 5</code>，即每五个区块中，对于一个分片，只能有至多一个合法的collation。</p><img src="/2020/11/04/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Ethereum_Sharding_Notes/20190302101802.png" class=""><p>所有分片的这个period的最新状态根会被记录在VMC的中，反映在VMC的状态。</p><img src="/2020/11/04/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Ethereum_Sharding_Notes/20190302101814.png" class=""><h3 id="分片链的分叉选择规则">分片链的分叉选择规则</h3><p>遵循“最长主链中的最长分片链”。</p><h3 id="仍然有的疑问">仍然有的疑问</h3><ul><li>collation是如何被进行多签名的？</li></ul>]]></content>
      
      
      <categories>
          
          <category> 01 IT </category>
          
          <category> 01 Theory </category>
          
          <category> How a Software Works </category>
          
          <category> 1_Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>比特币笔记</title>
      <link href="2020/11/01/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Bitcoin_Notes/"/>
      <url>2020/11/01/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Bitcoin_Notes/</url>
      
        <content type="html"><![CDATA[<h1>比特币笔记</h1><h2 id="比特币地址">比特币地址</h2><p>比特币使用Secp256k1椭圆曲线得到私钥、公钥。</p><p>公钥哈希是公钥进行HASH160（SHA256、RIPEMD160）而来的，为了方便阅读，再对公钥哈希使用BASE58CHECK编码成地址来显示。但是账本上是不会出现“地址”，只会出现公钥（解锁脚本里）和公钥哈希（锁定脚本里）。</p><p>地址是公钥哈希或者脚本哈希进行check58num或者bech32编码后的结果。</p><h2 id="交易">交易</h2><h3 id="非coinbase交易">非coinbase交易</h3><p><img src="/2020/11/01/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Bitcoin_Notes/%E6%AF%94%E7%89%B9%E5%B8%81%E4%BA%A4%E6%98%93%E7%BB%93%E6%9E%84.png" class=""></p><p>交易中的script可以看做是一个下推自动机的的形式语言，用来对栈进行存取和处理。</p><h3 id="coinbase交易">coinbase交易</h3><p>coinbase交易中的输入结构和普通交易不一样。</p><h3 id="交易结构中的lock-time">交易结构中的lock_time</h3><p>交易中的lock_time指示这笔交易在哪个时间才可以出现在链上。</p><h3 id="minrelaytxfee">minrelaytxfee</h3><p>一个节点有minrelaytxfee参数，现在版本默认为0.00001btc，可以修改，交易费低于minrelaytxfee的交易不会被转发。</p><h3 id="交易延展性（transaction-malleability）">交易延展性（transaction malleability）</h3><p>参考：</p><ul><li><a href="https://bitcoincore.org/en/2016/01/26/segwit-benefits/">https://bitcoincore.org/en/2016/01/26/segwit-benefits/</a></li><li><a href="https://en.bitcoin.it/wiki/Transaction_malleability">https://en.bitcoin.it/wiki/Transaction_malleability</a></li></ul><p>隔离见证可以解决交易延展性（transaction malleability）。</p><p>交易发送方可以将签名好的交易发送给比特币网络，并且可以计算出这笔交易的txid（用HASH256，即两次SHA256）。txid是交易在链上的唯一标志。</p><p>但是在交易进入共识链之前，被转发或者被矿工处理的过程中，内容可以被改变（但无法改变输入和输出），造成txid被改变。交易发送方无法按txid追索到自己发的交易。这称为第三方延展性（third-party malleability）。</p><h3 id="签名延展性（Signature-Malleability）">签名延展性（Signature Malleability）</h3><p>交易的输入中的每个输入的解锁脚本中有签名（ECDSA算法生成），攻击者可以在不掌握交易发送方的私钥（这个输入引用的输出的锁定脚本中的公钥哈希对应的私钥）的情况下重构一个不一样的但是合法的签名，造成txid的改变。主要原因是openssl不要求签名严格遵循DER-encoded ASN.1标准，BIP66软分叉要求签名严格遵守DER-encoded ASN.1标准以避免这个问题（看了DER编码和椭圆曲线，但是没大懂）。</p><p>采用隔离验证形式的新式交易将签名移到交易的script_witnesses字段，避免了这个问题。</p><h3 id="解锁脚本延展性（scriptSig-Malleability）">解锁脚本延展性（scriptSig Malleability）</h3><blockquote><p>The signature algorithm used in Bitcoin does not sign any of the scriptSig to create the signature. While signing the whole scriptSig would be impossible - the signature would be signing itself - this does mean that additional data can be added such that it will be pushed on the stack prior to the required signatures and public keys. Similarly OP_DROP can be added to leave the stack exactly as before prior to scriptPubKey execution.</p></blockquote><blockquote><p>Preventing scriptSig malleability is being considered as well. Currently transactions with anything other than data push operations in their scriptSig are considered non-standard and are not relayed, and eventually this rule may extend to enforcing that the stack have exactly one item after execution. However doing that may interfere with later extensions to Bitcoin.</p></blockquote><p>（不太理解，直接翻译了）比特币的签名算法不会对任何一个解锁脚本创建签名。尽管对整个解锁脚本签名是不可能的，签名会对自己进行签名，这意味着额外的数据可以被添加。额外的数据将会被推到栈（脚本运行时的用的栈）的被需要的签名和公钥前面。相似地，OP_DROP可以被添加，造成栈在解锁脚本执行之前恰好如之前的情况一样（？？？）。</p><p>如何防止解锁脚本延展性也正在被考虑。现在，解锁脚本里有除了push操作以外的操作的交易是不标准的，也不会被转发。以后这个规则可能会扩展到强制栈必须在执行完后恰好只有一个元素。然而做这个可能性向比特币之后的扩展性。</p><h2 id="隔离见证（segregated-witness）">隔离见证（segregated witness）</h2><p>参考：</p><ul><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki</a></li></ul><p>隔离见证（BIP141-BIP145描述）是软分叉。</p><p>隔离见证将交易格式从</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[nVersion][txins][txouts][nLockTime]</span><br></pre></td></tr></table></figure><p>改成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[nVersion][marker][flag][txins][txouts][witness][nLockTime]</span><br></pre></td></tr></table></figure><img src="/2020/11/01/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Bitcoin_Notes/20190302101503.png" class=""><p>其中，maker和flag的目的是为了与老的交易区别，对于老的节点来说，新交易看起来是0输入的交易。原因见BIP144。</p><p>witness字段由一个或者多个witness field组成，每一个输入（txin）对应一个witness field。每个witness field开头有个字节var_int表示要在脚本执行前在栈里预先压入几个东西。witness不是脚本。witness field里主要是签名和公钥。</p><p>BIP141提供了两种新的交易类型P2WPKH（向隔离见证公钥哈希付款）和P2WSH（向隔离见证脚本付款）。</p>]]></content>
      
      
      <categories>
          
          <category> 01 IT </category>
          
          <category> 01 Theory </category>
          
          <category> How a Software Works </category>
          
          <category> 1_Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>以太坊笔记</title>
      <link href="2020/11/01/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Ethereum_Notes/"/>
      <url>2020/11/01/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Ethereum_Notes/</url>
      
        <content type="html"><![CDATA[<h1>以太坊笔记</h1><h2 id="相关链接">相关链接</h2><ul><li><p><a href="https://github.com/JerryMissTom/go-ethereum">JerryMissTom/go-ethereum: Ethereum Frontier Guide中文版</a></p></li><li><p><a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis">ZtesoftCS/go-ethereum-code-analysis</a></p></li><li><p><a href="https://github.com/xianfeng92/Love-Ethereum">xianfeng92/Love-Ethereum: 区块链学习</a></p></li><li><p><a href="https://ethereum.stackexchange.com/questions/375/what-is-swarm-and-what-is-it-used-for">以太坊Swarm是什么</a></p></li><li><p><a href="https://ethfans.org/posts/diving-into-ethereums-world-state-part-1">以太坊世界状态解释</a></p></li><li><p><a href="https://ethfans.org/posts/getting-started-with-ethereum-s-swarm-on-the-testnet">以太坊本土分布式内容存储-在以太坊测试网络试运行Swarm</a></p></li></ul><h2 id="概念解释">概念解释</h2><ul><li><p>地址：与比特币相同，以太坊使用Secp256k1椭圆曲线得到私钥、公钥。</p></li><li><p>区块链状态：区块链是一个基于交易的状态机。以太坊区块头中只保存交易树、状态树和收据树的根节点哈希值。</p></li><li><p>收据（Receipt）：交易被执行后的区块链状态。包含存储交易执行后状态的字典树、总Gas使用量、Logs、基于Logs中信息的布隆过滤器。</p></li><li><p>Swarm：基于以太坊的存储服务。</p></li></ul><img src="/2020/11/01/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Ethereum_Notes/20190302100828.png" class=""><h2 id="无状态客户端（Stateless-Client）">无状态客户端（Stateless Client）</h2><p>参考：</p><ul><li><a href="https://medium.com/@akhounov/data-from-the-ethereum-stateless-prototype-8c69479c8abc">Data from the Ethereum stateless prototype</a></li></ul><p>无状态客户端的主要思路是在节点接收到区块并对区块内的交易执行时不必访问整个区块链状态。矿工会在区块内附加额外的数据结构，这个数据结构提供能够满足交易执行的部分全状态，同时也提供默克尔证明。</p>]]></content>
      
      
      <categories>
          
          <category> 01 IT </category>
          
          <category> 01 Theory </category>
          
          <category> How a Software Works </category>
          
          <category> 1_Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hyperledger Fabric 1.0 安装</title>
      <link href="2020/11/01/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Hyperledger%20Fabric%201.0%20%E5%AE%89%E8%A3%85/"/>
      <url>2020/11/01/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Hyperledger%20Fabric%201.0%20%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1>Hyperledger Fabric 1.0 安装</h1><ul><li><p>具体方法查看：<a href="http://hyperledger-fabric.readthedocs.io/en/latest/prereqs.html">http://hyperledger-fabric.readthedocs.io/en/latest/prereqs.html</a></p></li><li><p>我的安装环境是：Ubuntu 16.04</p></li></ul><h2 id="预安装软件注意点">预安装软件注意点</h2><p>  我在root下创建了hyperledger用户，并将其加入sudo组方便执行root的操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adduser hyperledger</span><br><span class="line">usermod -a -G sudo hyperledger</span><br><span class="line">usermod -a -G adm hyperledger</span><br></pre></td></tr></table></figure><h3 id="cUrl">cUrl</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install curl</span><br></pre></td></tr></table></figure><h3 id="Docker">Docker</h3><h4 id="docker">docker</h4><p>  文档里说要求高于17.03.1-ce的版本,所以写本文时安装了17.06.1-ce版本。docker-ce需要Ubuntu 14.04及以上版本。</p><p>  Docker 17.06.1-ce在Ubuntu下安装参考：<a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/#install-docker-ce">https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/#install-docker-ce</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><p>  为了能在普通用户下而不是root下使用docker，将用户hyperledger加入docker用户组（这里需要重新登陆一下然后生效）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G docker hyperledger</span><br></pre></td></tr></table></figure><h4 id="docker-compose">docker-compose</h4><p>  还需要一个docker-compose，Ubuntu16.04下可以直接这样安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-compose</span><br></pre></td></tr></table></figure><p>但是Ubuntu14.04下需要手动下载安装，加了阿里的软件源也不行。</p><h3 id="Node-js运行环境和NPM">Node.js运行环境和NPM</h3><p>  文档里说不支持Node.js的7.x版本，但要求6.9.x版本或者更高。<br>  我从<a href="https://nodejs.org/en/download/releases/">https://nodejs.org/en/download/releases/</a>这里进去找到<a href="https://nodejs.org/download/release/v6.11.2/node-v6.11.2-linux-x64.tar.gz">https://nodejs.org/download/release/v6.11.2/node-v6.11.2-linux-x64.tar.gz</a>，因为不是最新版的，所以只让本用户用，因此解压后放到~/.local目录下,改名为node（mv命令）。由于~/.profile会将~/.local/bin放入环境变量PATH中，因此做~/.local/node/bin链接到~/.local/bin：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir .<span class="built_in">local</span></span><br><span class="line"><span class="built_in">cd</span> ~/.<span class="built_in">local</span></span><br><span class="line">wget https://nodejs.org/download/release/v6.11.2/node-v6.11.2-linux-x64.tar.gz</span><br><span class="line">tar -xzf node-v6.11.2-linux-x64.tar.gz</span><br><span class="line">mv node-v6.11.2-linux-x64 node</span><br><span class="line">mkdir bin</span><br><span class="line">ln -s ~/.<span class="built_in">local</span>/node/bin/node ~/.<span class="built_in">local</span>/bin/node</span><br><span class="line">ln -s ~/.<span class="built_in">local</span>/node/bin/npm ~/.<span class="built_in">local</span>/bin/npm</span><br></pre></td></tr></table></figure><h3 id="Go语言">Go语言</h3><p>  apt下载来的go语言版本有点低，所以下载平台相关的离线二进制包来用。从<a href="https://studygolang.com/dl">https://studygolang.com/dl</a>下载<a href="https://storage.googleapis.com/golang/go1.9.1.linux-amd64.tar.gz">https://storage.googleapis.com/golang/go1.9.1.linux-amd64.tar.gz</a>解压后放在/usr/local,因为官方默认放在/usr/local,这样不用设置GOPATH环境变量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span></span><br><span class="line">sudo wget https://storage.googleapis.com/golang/go1.9.1.linux-amd64.tar.gz</span><br><span class="line">sudo tar -xzf ./go1.9.1.linux-amd64.tar.gz -C /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>这样/usr/local下会出现go目录，然后在/etc/profile增加以下语句：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br></pre></td></tr></table></figure><p>因为是安装在/usr/local/go，所以就不用设置GOROOT环境变量了，否则在/etc/profile增加以下语句：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=安装目录/go</span><br></pre></td></tr></table></figure><p>  然后设置本用户的GOPATH：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPATH=~/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;GOPATH//://bin:&#125;</span>/bin</span><br></pre></td></tr></table></figure><h2 id="安装Hyperledger-fabric注意点">安装Hyperledger fabric注意点</h2><h3 id="fabric二进制文件">fabric二进制文件</h3><p>  参考<a href="http://hyperledger-fabric.readthedocs.io/en/latest/samples.html#binaries">http://hyperledger-fabric.readthedocs.io/en/latest/samples.html#binaries</a>。<br>  在家目录下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir fabric</span><br><span class="line"><span class="built_in">cd</span> ~/fabric</span><br><span class="line">curl -sSL https://goo.gl/Gci9ZX | bash</span><br></pre></td></tr></table></figure><p>就可以安装好Hyperledger fabric了，~/fabric下出现bin目录，里面是一些配置channel和MSP等的工具。<br>  然后，要么把bin加入PATH变量或者把bin里的cryptogen、configtxgen、configtxlator、peer做个链接到~/bin。我采用了前面的操作，在~/.profile里加入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/fabric/bin</span><br></pre></td></tr></table></figure><h3 id="fabric源码和例程">fabric源码和例程</h3><p>  首先要设置好环境变量GOPATH，然后</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/hyperledger/fabric</span><br><span class="line"><span class="built_in">cd</span> ~/go/src/github.com/hyperledger/fabric</span><br><span class="line">git checkout v1.0.2<span class="comment">#切换到需要版本的源码</span></span><br></pre></td></tr></table></figure><p>在$GOPATH/src/github.com/hyperledger/fabric下就出现源码了，里面的examples目录就是例程。</p><h2 id="fabric-samples">fabric-samples</h2><p>  下载需要一些时间，这时候把Hyperledger fabric的samples下载过来，放在~/fabric。<br>新开一个终端，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/fabric</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hyperledger/fabric-samples.git</span><br></pre></td></tr></table></figure><p>产生的fabric-samples目录就是了。</p><h3 id="验证">验证</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/fabric/fabric-samples/first-network</span><br><span class="line">./byfn.sh -m generate</span><br><span class="line">./byfn.sh -m up</span><br></pre></td></tr></table></figure><p>看起来运行正常，说明安装成功了。</p>]]></content>
      
      
      <categories>
          
          <category> 01 IT </category>
          
          <category> 01 Theory </category>
          
          <category> How a Software Works </category>
          
          <category> 1_Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>比特币脚本与地址笔记</title>
      <link href="2020/11/01/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Script_and_Address_of_Bitcoin_Notes/"/>
      <url>2020/11/01/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Script_and_Address_of_Bitcoin_Notes/</url>
      
        <content type="html"><![CDATA[<h1>比特币脚本与地址笔记</h1><h2 id="一些概念的部分解释">一些概念的部分解释</h2><ul><li>非压缩式公钥：65字节，十六进制表示以04开头；</li><li>压缩式公钥：33字节，十六进制表示以02、03开头；</li><li>公钥哈希：20字节；</li><li>脚本哈希：20字节（或者32字节，但是没有见过实例）；</li><li>地址（由公钥哈希和脚本哈希组装和编码而来）：<ul><li>P2PKH型：十六进制以1开头，例如<code>1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2</code>，由公钥哈希组装和编码而来；</li><li>P2SH型：十六进制以3开头，例如<code>3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy</code>，由脚本哈希组装和编码而来；</li><li>bech32型：bc1来头，例如<code>bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq</code>，它是前两种地址的另一种表达格式，现在blockchain.info只在有“native witness program”的时候使用这种格式；</li></ul></li><li>签名：七十几字节（由第二个字节决定）；</li></ul><h2 id="研究的部分结论">研究的部分结论</h2><img src="/2020/11/01/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/Script_and_Address_of_Bitcoin_Notes/20190302101309.png" class=""><h3 id="非隔离见证交易（没有marker和flag的）">非隔离见证交易（没有marker和flag的）</h3><ul><li>锁定脚本：<code>41&lt;非压缩式公钥（65字节）&gt;AC（1开头地址）</code></li><li>锁定脚本(不太确定)：（P2PK型多重签名)OP_2 &lt;公钥1&gt; &lt;公钥2&gt; &lt;公钥3&gt; OP_3 CHECKMULTISIG(0xAE)（1开头地址）</li><li>锁定脚本：76A914&lt;公钥哈希&gt;(20bytes)88AC（1开头地址）</li><li>锁定脚本：76A914&lt;公钥哈希&gt;(20bytes)87AC（1开头地址）</li><li>锁定脚本：A914&lt;脚本哈希&gt;(20bytes)87（3开头地址）</li><li>锁定脚本：6A&lt;data&gt;(40bytes?)（没有地址，资金锁住了）</li></ul><h3 id="隔离见证交易（有marker和flag的）">隔离见证交易（有marker和flag的）</h3><ul><li>锁定脚本：0014&lt;哈希&gt;(20bytes)（bc1开头地址）</li><li>锁定脚本：0014&lt;哈希&gt;(20bytes)（bc1开头地址）</li><li>锁定脚本：A914&lt;脚本哈希&gt;(20bytes)87（3开头地址）</li><li>锁定脚本：A914&lt;脚本哈希&gt;(20bytes)87（3开头地址）</li></ul><h2 id="非隔离见证交易">非隔离见证交易</h2><h3 id="P2PKH（Pay-to-Public-Key-Hash）">P2PKH（Pay-to-Public-Key-Hash）</h3><h4 id="单签名（第一种）">单签名（第一种）</h4><p>//解锁脚本：&lt;Signature&gt; &lt;Public Key&gt; OP_DUP OP_HASH160<br>锁定脚本：OP_DUP(0x76) OP_HASH160(0xA9) PUSHDATA20(0x14) &lt;Public Key Hash&gt;(20bytes) OP_EQUAL(0x87) OP_CHECKSIG(0xAC)</p><p>举例：（书上说有这种交易，没有找到实例）</p><h4 id="单签名（第二种）">单签名（第二种）</h4><p>//解锁脚本：&lt;Signature&gt; &lt;Public Key&gt; OP_DUP OP_HASH160<br>锁定脚本：OP_DUP(0x76) OP_HASH160(0xA9) PUSHDATA20(0x14) &lt;Public Key Hash&gt;(20bytes)  OP_EQUALVERIFY(0x88) OP_CHECKSIG(0xAC)</p><p>交易举例：99c2f5d3f1a1c89a4afa522361c55664e7777c71b02fd66cdf4e2ba190551d11、5a4ebf66822b0b2d56bd9dc64ece0bc38ee7844a23ff1d7320a88c5fdb2ad3e2</p><h3 id="P2PK（Pay-to-Public-Key）">P2PK（Pay-to-Public-Key）</h3><h4 id="单签名">单签名</h4><p>锁定脚本：PUSHDATA65BYTES(0x41) &lt;非压缩式公钥&gt;(65bytes) OP_CHECKSIG(0xAC)</p><p>(获取公钥后需要通过HASH160获得公钥哈希)</p><p>这是比特币最早的锁定脚本，coinbase一般是这种形式。</p><p>交易举例：创世区块的交易</p><h3 id="多重签名">多重签名</h3><p>锁定脚本：M PUSHDATA65(0x41) &lt;Public Key 1&gt; PUSHDATA65(0x41)<br>&lt;Public Key 2&gt; … PUSHDATA65(0x41) &lt;Public Key N&gt; N OP_CHECKMULTISIG(0xAE)</p><p>（因为实例没有找到，这个锁定脚本形式有待验证，因为M是个操作数，但是之前没有操作码）</p><p>交易举例：（没找到）</p><h3 id="P2SH（Pay-to-Script-Hash）">P2SH（Pay-to-Script-Hash）</h3><p>赎回脚本（2-3）：<br>OP_2(0x52)<br>OP_PUSHDATA33BYTES(0x21)&lt;压缩式公钥1&gt;<br>OP_PUSHDATA33BYTES(0x21)&lt;压缩式公钥2&gt;<br>OP_PUSHDATA33BYTES(0x21)&lt;压缩式公钥3&gt;<br>OP_3(0x53)<br>OP_CHECKMULTISIG(0xAE)</p><p>解锁脚本：<br>OP_PUSHDATA?BYTES &lt;Sig1&gt;<br>OP_PUSHDATA?BYTES &lt;Sig2&gt;<br>OP_PUSHDATA?BYTES &lt;赎回脚本&gt;</p><p>锁定脚本：<br>HASH160(0xA9)<br>PUSHDATA20(0x14) &lt;脚本哈希（赎回脚本的HASH160）&gt;(20bytes) OP_EQUAL(0x87)</p><p>举例：<br>txid为<code>521f7c6781ced91da6cc8eb4c64b283d2e99f98627daf8a3a0c60432d8e8f601</code>的输入</p><p>解锁脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00&#x2F;&#x2F;这是要注意！这是什么？？？版本号？</span><br><span class="line">OP_PUSHDATA71BYTES(0x47)</span><br><span class="line">3044022027eec2f3081b87d271e32e126c9ccb4d2c4afa7ef14f7cff644723784b720ede02203e278a13e3544bd32abe6592e4e17a7331272db4a2b780113ed24e3ca3c37f3201&#x2F;&#x2F;签名1</span><br><span class="line">OP_PUSHDATA72BYTES(0x48)</span><br><span class="line">30450221009e450de0b27f95db02d7ab8b5943c62b8e2f50eabfb017f509684c4f58892d7802203b8640c5f17b8e6239a65f66bbb26ea952dac9d0eefffd114d97878b2ac1da4f01&#x2F;&#x2F;签名1</span><br><span class="line">OP_PUSHDATA1(0x4c)69</span><br><span class="line">OP_2(0x52)</span><br><span class="line">OP_PUSHDATA33BYTES(0x21)</span><br><span class="line">02ca355b567bff51c9b4a1c1590e25f685f8d12273efb7f7685a50e546786d0de7&#x2F;&#x2F;公钥1</span><br><span class="line">OP_PUSHDATA33BYTES(0x21)</span><br><span class="line">03e5fa93cffa7533c6b68906c4a9b8665f5167f3ed95b830328835ca4d39b6495f&#x2F;&#x2F;公钥2</span><br><span class="line">OP_PUSHDATA33BYTES(0x21)</span><br><span class="line">03ee6664f625e0a44fad0ad53ae1ecdc7c7239346b81514e8f87cfd2be4f8fec21&#x2F;&#x2F;公钥3</span><br><span class="line">OP_3(0x53) </span><br><span class="line">OP_CHECKMULTISIG(0xae)</span><br></pre></td></tr></table></figure><p>锁定脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a914d0982dd391d674f101898e8500586019e01d9aa787</span><br></pre></td></tr></table></figure><h2 id="OP-RETURN">OP_RETURN</h2><p>锁定脚本：OP_RETURN(0x6A) &lt;data&gt;(40bytes?)</p><p>输出不能被花费。</p><h2 id="纯隔离见证交易">纯隔离见证交易</h2><p>witness_version在witness字段内，锁定脚本必然以一个版本号开头</p><h3 id="P2WPKH（pay-to-witness-public-key-hash）">P2WPKH（pay-to-witness-public-key-hash）</h3><p>witness: &lt;signature&gt; &lt;pubkey&gt;<br>解锁脚本: 空<br>锁定脚本: witness_version(0x00) PUSHDATA20BYTES(0x14) &lt;公钥哈希&gt;(20bytes)</p><p>交易举例：没有找到实例……</p><h3 id="P2WSH（pay-to-witness-script-hash）">P2WSH（pay-to-witness-script-hash）</h3><p>witness: witness_version(0x00) OP_PUSHDATA?BYTES &lt;签名1&gt; OP_1 OP_PUSHDATA33BYTES &lt;压缩式公钥1&gt; OP_PUSHDATA33BYTES &lt;压缩式公钥2&gt; OP_2 OP_CHECKMULTISIG(0xAE)<br>解锁脚本: 空<br>锁定脚本1: witness_version(0x00) PUSHDATA32BYTES(0x20) &lt;脚本哈希&gt;(32bytes)<br>锁定脚本2: witness_version(0x00) PUSHDATA20BYTES(0x14) &lt;脚本哈希&gt;(20bytes)<br>锁定脚本3: witness_version(非0x00) PUSHDATA任意BYTES &lt;脚本哈希&gt;(任意bytes)<br>(注意：P2SH的脚本哈希只有20字节，这里可以20字节或者32字节，32字节是为了防碰撞)</p><p>交易举例：txid为<code>d38f496e1004895c52d35bfe392800024b78b40e30dd063c4728058088ea0620</code>交易的输入</p><p>witness：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">04&#x2F;&#x2F;？？</span><br><span class="line">witness_version(0x00)</span><br><span class="line">47</span><br><span class="line">304402203f87ea2cb39bf7b57f0ada40cfa7178a7b11548767d17be57e0e3a9ed818e53902202323afa3875a9917bf8227051ea5805ea5bc7a71f1ef8176884964a278aa2c2b01&#x2F;&#x2F;签名</span><br><span class="line">47</span><br><span class="line">304402201055076d4a5284509a8c3e01abbe5e34e4fd79fe823914821bcaa7924333e0e40220495237c0d9acd7f16357de8c89e4eaab620ce5d26b810214e96272f4cf27b54e01&#x2F;&#x2F;签名</span><br><span class="line">OP_VERIFY(0x69)</span><br><span class="line">OP_2(0x52)</span><br><span class="line">21</span><br><span class="line">0375e00eb72e29da82b89367947f29ef34afb75e8654f6ea368e0acdfd92976b7c&#x2F;&#x2F;公钥</span><br><span class="line">21</span><br><span class="line">03a1b26313f430c4b15bb1fdce663207659d8cac749a0e53d70eff01874496feff&#x2F;&#x2F;公钥</span><br><span class="line">21</span><br><span class="line">03c96d495bfdd5ba4145e3e046fee45e84a8a48ad05bd8dbb395c011a32cf9f880&#x2F;&#x2F;公钥</span><br><span class="line">OP_3(0x53)</span><br><span class="line">ae</span><br></pre></td></tr></table></figure><h2 id="将P2WPKH和P2WSH的witness-program嵌入P2SH赎回脚本的部分">将P2WPKH和P2WSH的witness program嵌入P2SH赎回脚本的部分</h2><p>witness_version在解锁脚本内。</p><h3 id="P2WPKH-nested-in-BIP16-P2SH">P2WPKH nested in BIP16 P2SH</h3><p>witness: &lt;signature&gt; &lt;pubkey&gt;<br>解锁脚本: PUSHDATA22BYTES(0x16) witness_version(00)PUSHDATA22BYTES(0x14) &lt;公钥哈希&gt;(20bytes)<br>锁定脚本: OP_HASH160(0xA9) PUSHDATA20BYTES(0x14) &lt;脚本哈希&gt;(20bytes) OP_EQUAL(0x87)</p><p>举例：交易c420d6cf09973d4a539cb17acdc42a3a89a89e0d6e28938a37951085d8433125的输出</p><h3 id="P2WSH-nested-in-BIP16-P2SH">P2WSH nested in BIP16 P2SH</h3><p>witness:0 &lt;signature1&gt; &lt;1 &lt;pubkey1&gt; &lt;pubkey2&gt; 2 CHECKMULTISIG&gt;<br>解锁脚本1: PUSHDATA34BYTES(0x22) witness_version(00) PUSHDATA32BYTES(0x20) &lt;脚本哈希&gt; (32bytes)<br>解锁脚本2: PUSHDATA22BYTES(0x16) witness_version(00) PUSHDATA20BYTES(0x14) &lt;脚本哈希&gt; (20bytes)<br>锁定脚本: OP_HASH160(0xa9) OP_PUSHDATA20(0x14) &lt;20-byte-hash&gt; OP_EQUAL(0x87)</p><p>交易举例：</p><ul><li>4967d6427b17a17e91b524e9a4f8a810182c5f9995fd07fe2eab71d9cc96ecc0</li></ul>]]></content>
      
      
      <categories>
          
          <category> 01 IT </category>
          
          <category> 01 Theory </category>
          
          <category> How a Software Works </category>
          
          <category> 1_Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>区块链共识算法学习笔记</title>
      <link href="2020/11/01/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/01/01%20IT/01%20Theory/How%20a%20Software%20Works/1_Blockchain/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>区块链共识算法学习笔记</h1><p>参考：<br><a href="http://blog.csdn.net/lsttoy/article/details/61624287">http://blog.csdn.net/lsttoy/article/details/61624287</a><br><a href="http://bbs.tianya.cn/m/post-me-150924-1.shtml">http://bbs.tianya.cn/m/post-me-150924-1.shtml</a></p><h2 id="拜占庭将军问题（Byzantine-Generals-Problem）">拜占庭将军问题（Byzantine Generals Problem）</h2><p><a href="https://yq.aliyun.com/articles/429909">https://yq.aliyun.com/articles/429909</a></p><p>拜占庭帝国的几支军队攻打到了敌人的城市外面，然后分开驻扎。每一支军队由一位拜占庭将军(Byzantine general)率领。为了制定出一个统一的作战计划，每一位将军需要通过信差(messenger)与其它将军互通消息。但是，在拜占庭将军之间可能出现了叛徒(traitor)。这些叛徒将军的目的是阻挠其他忠诚的将军(loyal generals)达成一致的作战计划。为了这一目的，他们可能做任何事，比如串通起来，故意传出虚假消息，或者不传出任何消息。</p><p>要解决这个问题，我们是希望能找到一个算法，保证在存在叛徒阻挠的情况下，我们仍然能够达成如下目标：</p><p>A. 所有忠诚的将军都得到了相同（一致）的作战计划。比如都决定进攻，或都决定撤退，而不是有些将军认为应该进攻，其他将军却决定撤退。</p><p>B. 忠诚的将军不仅得到了相同的作战计划，还应该保证得到的作战计划是合理的(reasonable)。比如，本来进攻是更有利的作战计划，但由于叛徒的阻挠，最终却制定出了一起撤退的计划。这样我们的算法也算失败了。</p><h2 id="PoW（Proof-of-Work，工作量证明）">PoW（Proof of Work，工作量证明）</h2><p>比特币在Block的生成过程中使用了PoW机制，一个符合要求的Block Hash由N个前导零构成，零的个数取决于网络的难度值。要得到合理的Block Hash需要经过大量尝试计算，计算时间取决于机器的哈希运算速度。当某个节点提供出一个合理的Block Hash值，说明该节点确实经过了大量的尝试计算，当然，并不能得出计算次数的绝对值，因为寻找合理哈希是一个概率事件。当节点拥有占全网n%的算力时，该节点即有n/100的概率找到Block Hash。</p><h1>PoS（Proof of Stake，股权证明）</h1><p>PoS也称股权证明，类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。</p><p>简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明PoS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你__发现了一个PoS区块__，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。</p><p>这里所谓的__发现了一个PoS区块__，可以是如下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHA256(SHA256(Bprev),A,t)≤balance(A)×m</span><br></pre></td></tr></table></figure><p>t为UTC时间戳，Bprev指的是上个区块，balance(A)代表账户A币龄，m是某个固定的实数，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHA256(上一个区块的哈希,A,t)≤balance(A)×m</span><br></pre></td></tr></table></figure><p>唯一的变量就是时间戳t，t不能超过标准时间戳1小时，所以账户A币龄越大，越容易找到合法的下一个区块。</p><h2 id="DPoS（Delegated-Proof-of-Stake，委任权益证明）">DPoS（Delegated Proof of Stake，委任权益证明）</h2><p>比特股的DPoS机制，中文名叫做股份授权证明机制（又称受托人机制），它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上，类似演唱会的黄牛，大量囤票而丝毫不关心演唱会的内容。</p><h2 id="PBFT（Practical-Byzantine-Fault-Tolerance，实用拜占庭容错算法）">PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错算法）</h2><p>PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到|R|-1的整数表示每一个副本。为了描述方便，假设|R|=3f+1，这里f是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。</p><h3 id="PBFT过程">PBFT过程</h3><ol><li>从全网节点选举出一个主节点（Leader），新区块由主节点负责生成。</li><li>每个节点把客户端发来的交易向全网广播，主节点将从网络收集到需放在新区块内的多个交易排序后存入列表，并将该列表向全网广播。</li><li>每个节点接收到交易列表后，根据排序模拟执行这些交易。所有交易执行完后，基于交易结果计算新区块的哈希摘要，并向全网广播。</li><li>如果一个节点收到的2f（f为可容忍的拜占庭节点数）个其它节点发来的摘要都和自己相等，就向全网广播一条commit消息。</li><li>如果一个节点收到2f+1条commit消息，即可提交新区块及其交易到本地的区块链和状态数据库。<br>注：4个节点可以容忍一个内奸（拜占庭节点），3n+1个节点可以容忍n个内奸</li></ol><h2 id="总结">总结</h2><p>以上主要是目前主流的共识算法。<br>　　从时间上来看，这个顺序也是按该共识算法从诞生到热门的顺序来定。<br>　　对于PoW，直接让比特币成为了现实，并投入使用。而PoS的存在主要是从经济学上的考虑和创新。而最终由于专业矿工和矿机的存在，让社区对这个标榜去中心化的算法有了实质性的中心化担忧，即传闻60％～70%的算力集中在中国。因此后来又出现DPOS，这种不需要消耗太多额外的算力来进行矿池产出物的分配权益方式。但要说能起到替代作用，DPoS来单独替代PoW，PoS或者PoW＋PoS也不太可能，毕竟存在即合理。每种算法都在特定的时间段中有各自的考虑和意义，无论是技术上，还是业务上。</p><p>如果跳出技术者的角度，更多结合政治与经济的思考方式在里面，或许还会跳出更多的共识算法，如结合类似PPP概念的共识方式，不仅能达到对恶意者的惩罚性质，还能达到最高效节约算力的目的也说不定。</p><p>至于说算法的选择，这里引用万达季总的这一段话作为结束：</p><p>一言以蔽之，共识最好的设计是模块化,例如Notary，共识算法的选择与应用场景高度相关，可信环境使用paxos 或者raft，带许可的联盟可使用pbft ，非许可链可以是pow，pos，ripple共识等，根据对手方信任度分级，自由选择共识机制，这样才是真的最优。</p>]]></content>
      
      
      <categories>
          
          <category> 01 IT </category>
          
          <category> 01 Theory </category>
          
          <category> How a Software Works </category>
          
          <category> 1_Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
