---
title: 设计模式笔记
date: '2020-12-27 00:15:16'
updated: '2023-05-07 20:03:11'
categories:
  - 1 Design Pattern
---

# 设计模式笔记

## 设计原则

### 开闭原则（OCP）

　　在设计一个软件的时候，应当使这个软件可以在不被修改的前提下扩展。
　　
### 封装可变性

　　“考虑到你的设计中什么可能会发生变化，考虑你允许什么发生变化而不让这一变化导致重新设计”。
　　
　　一种可变性不应散落宅代码的很多角落。
　　
　　一种可变性不应当与另一种可变性混合在一起。
　　
### 组合优先


　　
### 里氏代换原则

　　凡是父类适用的地方子类应当也适用。
　　
### 依赖倒置原则

　　要针对接口编程，不要针对实现编程。
　　
　　具体而言，变量不要持有具体类的引用、返回值要是抽象类型、不要重载父类的非抽象方法等。
　　
### 迪米特法则

　　每个软件单元对其他单元尽可能少了解而且仅限于那些与自己密切相关的单元。
　　
### 接口隔离原则（ISP）

　　一个类对另一个类的依赖应当建立在最小的接口上。
　　
### 单一职责原则（SRP）



## 设计模式

### 桥梁模式（Bridge）

　　将抽象部分和实现部分分别封装，可以分别独立变化。

### 策略模式（Strategy）

　　将算法封装成一个一个的类，任意地替换。桥梁模式包含策略模式。
　　
　　[与工厂模式的区别](#策略模式与工厂模式的区别)

### 适配器模式（Adapter）

　　将一个类的接口转换成客户希望的另外一种接口。
　　
　　实现方法有两种，常用的是采用适配器类对象持有被适配类对象的方法，还可以采用多继承的方法。

### 工厂模式（Factory）

　　由客户代码决定通过工厂类对象创建哪种类的对象。
　　
　　[与策略模式的区别](#策略模式与工厂模式的区别)

### 门面模式（Facade）

　　提供一个更简单的系统接口，使得复杂系统和客户代码耦合松散。但是并不屏蔽原有的复杂但是功能强大的接口，用户可以在易用性和通用性之间选择。

### 命令模式（Command）

　　请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。从而实现松散耦合。

### 模板方法模式（Template Method）

　　一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。
　　
　　模板方法模式封装了算法的可变性。常见的“钩子”、“回调”就是使用了模板方法模式。

### 观察者模式（Observer）

　　当一个对象发生修改时，则会自动通知依赖它的多个对象（它持有这些依赖的引用）。

### 单例模式（Singleton）

　　类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

### 装饰者模式（Decorator）

　　这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。该模式是继承的一种替代方法。

### 状态模式（State）

　　类的行为是基于它的接收到的状态对象后会发生改变。状态类派生于一个抽象基类，包含该基类的抽象方法的实现。
　　
　　与策略模式的区别是策略模式对象创建后不会发生状态的改变。
　　
## 设计模式之间的关系和区别

### 策略模式与工厂模式的区别

工厂模式：生成的对象的类型在创建时指定。
策略模式：生成的对象的各个方法的行为在创建时指定。
